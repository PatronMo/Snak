<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake PRO AI</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{
    margin:0;
    background:#0f0f0f;
    color:white;
    font-family:Arial,sans-serif;
    text-align:center;
}
h1{margin:10px;}
canvas{
    background:#000;
    border:3px solid #00ff88;
    border-radius:12px;
    box-shadow:0 0 25px #00ff8844;
}
button{
    margin:10px;
    padding:10px 18px;
    font-size:15px;
    border:none;
    border-radius:10px;
    font-weight:600;
    background:#00ff88;
    cursor:pointer;
}
</style>
</head>
<body>

<h1>Snake PRO â€” Smart Auto Collect</h1>
<button id="autoBtn">Auto Collect: OFF</button>
<div>Score: <span id="score">0</span></div>
<canvas id="game" width="600" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const autoBtn = document.getElementById("autoBtn");

let autoMode=false;
autoBtn.onclick=()=>{
    autoMode=!autoMode;
    autoBtn.textContent="Auto Collect: "+(autoMode?"ON":"OFF");
};

const size=20;
const tiles=canvas.width/size;

let snake=[{x:10,y:10}];
let dir={x:1,y:0};
let nextDir=dir;
let food=spawnFood();
let score=0;

let speed=6;           // FIXED balanced speed
let moveTimer=0;
let moveInterval=120;  // ms per move (smooth + controllable)

function spawnFood(){
    let f;
    do{
        f={
            x:Math.floor(Math.random()*tiles),
            y:Math.floor(Math.random()*tiles)
        };
    }while(snake.some(s=>s.x===f.x&&s.y===f.y));
    return f;
}

document.addEventListener("keydown",e=>{
    if(e.key==="ArrowUp"&&dir.y!==1) nextDir={x:0,y:-1};
    if(e.key==="ArrowDown"&&dir.y!==-1) nextDir={x:0,y:1};
    if(e.key==="ArrowLeft"&&dir.x!==1) nextDir={x:-1,y:0};
    if(e.key==="ArrowRight"&&dir.x!==-1) nextDir={x:1,y:0};
});

function gameLoop(time){
    moveTimer+=time-lastTime;
    lastTime=time;

    if(moveTimer>moveInterval){
        update();
        moveTimer=0;
    }

    draw();
    requestAnimationFrame(gameLoop);
}

let lastTime=0;

function update(){
    if(autoMode) aiMove();

    dir=nextDir;

    const head={
        x:snake[0].x+dir.x,
        y:snake[0].y+dir.y
    };

    if(head.x<0||head.y<0||head.x>=tiles||head.y>=tiles) return reset();

    if(snake.some(s=>s.x===head.x&&s.y===head.y)) return reset();

    snake.unshift(head);

    if(head.x===food.x&&head.y===food.y){
        score++;
        scoreEl.textContent=score;
        food=spawnFood();

        // slow controlled acceleration
        if(moveInterval>70) moveInterval-=2;
    }else{
        snake.pop();
    }
}

function reset(){
    snake=[{x:10,y:10}];
    dir={x:1,y:0};
    nextDir=dir;
    score=0;
    moveInterval=120;
    scoreEl.textContent=score;
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="#ff0044";
    ctx.fillRect(food.x*size,food.y*size,size,size);

    snake.forEach((s,i)=>{
        const alpha=1-(i/snake.length)*0.6;
        ctx.fillStyle=`rgba(0,255,136,${alpha})`;
        ctx.fillRect(s.x*size,s.y*size,size,size);
    });
}

/* ============================
   PRO AI (A* + survival logic)
   ============================ */

function aiMove(){
    const path=findPath(snake[0],food);

    if(path && path.length>1){
        const next=path[1];
        nextDir={x:next.x-snake[0].x,y:next.y-snake[0].y};
        return;
    }

    // if no safe food path -> follow tail survival
    const tail=snake[snake.length-1];
    const tailPath=findPath(snake[0],tail,true);

    if(tailPath && tailPath.length>1){
        const next=tailPath[1];
        nextDir={x:next.x-snake[0].x,y:next.y-snake[0].y};
        return;
    }

    // fallback safe move
    safeMove();
}

function safeMove(){
    const options=[
        {x:0,y:-1},
        {x:0,y:1},
        {x:-1,y:0},
        {x:1,y:0}
    ];

    for(let opt of options){
        const nx=snake[0].x+opt.x;
        const ny=snake[0].y+opt.y;

        if(nx<0||ny<0||nx>=tiles||ny>=tiles) continue;
        if(snake.some(s=>s.x===nx&&s.y===ny)) continue;

        nextDir=opt;
        return;
    }
}

function findPath(start,target,ignoreTail=false){
    const open=[start];
    const cameFrom={};
    const gScore={};
    const fScore={};

    const key=p=>p.x+","+p.y;

    gScore[key(start)]=0;
    fScore[key(start)]=heuristic(start,target);

    while(open.length){
        open.sort((a,b)=>fScore[key(a)]-fScore[key(b)]);
        const current=open.shift();

        if(current.x===target.x&&current.y===target.y){
            return reconstructPath(cameFrom,current);
        }

        const neighbors=[
            {x:current.x+1,y:current.y},
            {x:current.x-1,y:current.y},
            {x:current.x,y:current.y+1},
            {x:current.x,y:current.y-1}
        ];

        for(let n of neighbors){
            if(n.x<0||n.y<0||n.x>=tiles||n.y>=tiles) continue;

            if(!ignoreTail){
                if(snake.some(s=>s.x===n.x&&s.y===n.y)) continue;
            }else{
                if(snake.slice(0,-1).some(s=>s.x===n.x&&s.y===n.y)) continue;
            }

            const tentative=gScore[key(current)]+1;

            if(tentative < (gScore[key(n)] ?? Infinity)){
                cameFrom[key(n)]=current;
                gScore[key(n)]=tentative;
                fScore[key(n)]=tentative+heuristic(n,target);

                if(!open.some(o=>o.x===n.x&&o.y===n.y)) open.push(n);
            }
        }
    }
    return null;
}

function reconstructPath(cameFrom,current){
    const path=[current];
    while(cameFrom[current.x+","+current.y]){
        current=cameFrom[current.x+","+current.y];
        path.unshift(current);
    }
    return path;
}

function heuristic(a,b){
    return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
