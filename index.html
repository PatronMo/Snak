<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Smooth Smart Snake</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body{
        margin:0;
        background:#0f0f0f;
        color:white;
        font-family:Arial, sans-serif;
        text-align:center;
    }
    h1{
        margin:10px 0;
        font-weight:600;
        letter-spacing:1px;
    }
    canvas{
        background:#000;
        border:3px solid #00ff88;
        box-shadow:0 0 20px #00ff8855;
        border-radius:12px;
        margin-top:10px;
    }
    button{
        margin:10px;
        padding:12px 20px;
        border-radius:10px;
        border:none;
        font-size:16px;
        font-weight:600;
        cursor:pointer;
        background:#00ff88;
        color:black;
        transition:0.2s;
    }
    button:hover{
        transform:scale(1.05);
    }
</style>
</head>
<body>

<h1>Smooth Snake â€” Smart Auto Collect</h1>
<button id="autoBtn">Auto Collect: OFF</button>
<div>Score: <span id="score">0</span></div>
<canvas id="game" width="600" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const autoBtn = document.getElementById("autoBtn");

let autoMode = false;
autoBtn.onclick = () => {
    autoMode = !autoMode;
    autoBtn.textContent = "Auto Collect: " + (autoMode ? "ON" : "OFF");
};

const size = 20;
const tileCount = canvas.width / size;

let snake = [{x:10, y:10}];
let dir = {x:1, y:0};
let nextDir = dir;
let food = spawnFood();
let score = 0;

let speed = 4;        // was 8
const step = 1/12;    // was 1/15
let lastTime = 0;
let accumulator = 0;
const step = 1/15;

function spawnFood(){
    return {
        x: Math.floor(Math.random()*tileCount),
        y: Math.floor(Math.random()*tileCount)
    };
}

document.addEventListener("keydown", e=>{
    if(e.key==="ArrowUp" && dir.y!==1) nextDir={x:0,y:-1};
    if(e.key==="ArrowDown" && dir.y!==-1) nextDir={x:0,y:1};
    if(e.key==="ArrowLeft" && dir.x!==1) nextDir={x:-1,y:0};
    if(e.key==="ArrowRight" && dir.x!==-1) nextDir={x:1,y:0};
});

function gameLoop(time){
    const delta = (time-lastTime)/1000;
    lastTime = time;
    accumulator += delta*speed;

    while(accumulator > step){
        update();
        accumulator -= step;
    }

    draw();
    requestAnimationFrame(gameLoop);
}

function update(){
    if(autoMode) smartAI();

    dir = nextDir;

    const head = {
        x: snake[0].x + dir.x,
        y: snake[0].y + dir.y
    };

    // wall collision
    if(head.x<0||head.y<0||head.x>=tileCount||head.y>=tileCount){
        reset();
        return;
    }

    // self collision
    for(let s of snake){
        if(head.x===s.x && head.y===s.y){
            reset();
            return;
        }
    }

    snake.unshift(head);

    // eat
    if(head.x===food.x && head.y===food.y){
        score++;
        speed += 0.2;
        scoreEl.textContent = score;
        food = spawnFood();
    } else {
        snake.pop();
    }
}

function reset(){
    snake=[{x:10,y:10}];
    dir={x:1,y:0};
    nextDir=dir;
    score=0;
    speed=8;
    scoreEl.textContent=score;
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // food glow
    ctx.fillStyle="#ff0044";
    ctx.beginPath();
    ctx.arc(food.x*size+size/2, food.y*size+size/2, size/2, 0, Math.PI*2);
    ctx.fill();

    // snake smooth gradient
    snake.forEach((s,i)=>{
        const alpha = 1 - (i/snake.length)*0.6;
        ctx.fillStyle = `rgba(0,255,136,${alpha})`;
        ctx.fillRect(s.x*size, s.y*size, size, size);
    });
}

// ---------------- SMART AUTO AI ----------------

// Predict safe moves using scoring system
function smartAI(){
    const head = snake[0];

    const options = [
        {x:0,y:-1},
        {x:0,y:1},
        {x:-1,y:0},
        {x:1,y:0}
    ];

    let bestMove = dir;
    let bestScore = -999999;

    for(let opt of options){
        if(opt.x===-dir.x && opt.y===-dir.y) continue;

        const nx = head.x + opt.x;
        const ny = head.y + opt.y;

        // avoid wall
        if(nx<0||ny<0||nx>=tileCount||ny>=tileCount) continue;

        // avoid body
        let hitsBody = snake.some(s=>s.x===nx && s.y===ny);
        if(hitsBody) continue;

        // scoring
        let score = 0;

        // distance to food (prefer closer)
        const dist = Math.abs(food.x-nx) + Math.abs(food.y-ny);
        score -= dist * 5;

        // prefer open space (lookahead)
        score += floodFillSpace(nx,ny)*2;

        // avoid tight corridors
        score -= nearbyBodyPenalty(nx,ny);

        if(score > bestScore){
            bestScore = score;
            bestMove = opt;
        }
    }

    nextDir = bestMove;
}

// check available space from position (smart survival)
function floodFillSpace(x,y){
    const visited = new Set();
    const stack = [{x,y}];
    let count = 0;

    while(stack.length && count < 80){
        const node = stack.pop();
        const key = node.x+","+node.y;
        if(visited.has(key)) continue;
        visited.add(key);

        if(node.x<0||node.y<0||node.x>=tileCount||node.y>=tileCount) continue;
        if(snake.some(s=>s.x===node.x && s.y===node.y)) continue;

        count++;

        stack.push({x:node.x+1,y:node.y});
        stack.push({x:node.x-1,y:node.y});
        stack.push({x:node.x,y:node.y+1});
        stack.push({x:node.x,y:node.y-1});
    }
    return count;
}

function nearbyBodyPenalty(x,y){
    let penalty=0;
    snake.forEach(s=>{
        const d = Math.abs(s.x-x)+Math.abs(s.y-y);
        if(d===1) penalty+=8;
    });
    return penalty;
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
